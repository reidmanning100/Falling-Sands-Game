<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Falling Sand Game</title>
    <script defer src="/_vercel/insights/script.js"></script>
    <style>
        :root {
            /* Default theme (dark) */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #333;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --accent-primary: #444;
            --accent-hover: #555;
            --border-color: #333;
            --canvas-border: #333;
            --chat-bg: #2a2a2a;
            --chat-border: #333;
            --button-radius: 5px;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --element-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-primary);
            font-family: Arial, sans-serif;
            color: var(--text-primary);
            overflow: hidden;
            touch-action: none;
            min-height: 100vh;
            padding-bottom: 40px; /* Add padding at bottom */
        }

        .game-container {
            display: flex;
            gap: 20px;
            margin: 10px;
            align-items: flex-start;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            padding-bottom: 100px;
            position: relative;
            z-index: 1;
        }

        #canvas {
            border: 2px solid var(--canvas-border);
            background-color: #000;
            max-width: 100%;
            height: auto;
            position: relative;
            z-index: 2;
        }

        .chat-container {
            width: 300px;
            background-color: var(--chat-bg);
            border: 2px solid var(--chat-border);
            border-radius: var(--button-radius);
            padding: 15px;
            display: flex;
            flex-direction: column;
            height: 500px;
            margin-bottom: 40px;
            position: relative;
            z-index: 2;
        }

        button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: var(--button-radius);
            background-color: var(--accent-primary);
            color: var(--text-primary);
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--accent-hover);
        }

        button.active {
            background-color: var(--accent-hover);
            box-shadow: var(--element-shadow);
        }

        .theme-picker-button {
            padding: 6px 10px;
            font-size: 13px;
            margin: 5px 0;
            background-color: var(--accent-primary);
            color: var(--text-primary);
            border: none;
            border-radius: var(--button-radius);
            cursor: pointer;
        }

        .theme-picker-button:hover {
            background-color: var(--accent-hover);
        }

        .theme-picker-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--bg-secondary);
            padding: 20px;
            border-radius: var(--button-radius);
            box-shadow: 0 0 20px var(--shadow-color);
            z-index: 1000;
            width: 400px;
            max-width: 90%;
        }

        .theme-picker-popup.active {
            display: block;
        }

        .theme-picker-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .theme-option {
            padding: 15px;
            border-radius: var(--button-radius);
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .theme-option:hover {
            transform: scale(1.02);
        }

        .theme-option.active {
            border-color: var(--text-primary);
            transform: scale(1.02);
        }

        .theme-preview {
            width: 100%;
            height: 60px;
            border-radius: var(--button-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-weight: bold;
        }

        .theme-name {
            text-align: center;
            font-size: 14px;
            color: var(--text-primary);
        }

        .theme-picker-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 20px;
            cursor: pointer;
        }

        .theme-picker-title {
            color: var(--text-primary);
            margin-bottom: 15px;
            text-align: center;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }

            .chat-container {
                width: 90%;
                max-width: 300px;
                height: 300px;
            }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
                gap: 5px;
            }

            button {
                padding: 8px 12px;
                font-size: 14px;
            }

            .brush-controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            input[type="range"] {
                width: 120px;
            }
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .export-button {
            padding: 5px 10px;
            font-size: 12px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .export-button:hover {
            background-color: #666;
        }

        .chat-box {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            min-height: 300px;
        }

        .disclaimer {
            background-color: #444;
            color: #ff6b6b;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 14px;
            text-align: center;
            border: 1px solid #ff6b6b;
        }

        .active-comments {
            flex-grow: 1;
            min-height: 0;
        }

        .hidden-comments-section {
            margin-top: 10px;
            border-top: 1px solid #444;
            padding-top: 10px;
            background-color: #333;
            margin-bottom: 10px;
        }

        .hidden-comments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 8px;
            background-color: #444;
            border-radius: 3px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .hidden-comments-header:hover {
            background-color: #555;
        }

        .hidden-comments-content {
            display: none;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            background-color: #333;
        }

        .hidden-comments-content.expanded {
            display: block;
        }

        .comment {
            background-color: #444;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            word-wrap: break-word;
            position: relative;
        }

        .comment .timestamp {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        .hide-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .hide-button:hover {
            background-color: #555;
            color: #fff;
        }

        .restore-button {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }

        .restore-button:hover {
            background-color: #555;
            color: #fff;
        }

        .controls {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-picker {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: white;
            transform: scale(1.1);
        }

        .color-picker-button {
            padding: 6px 10px;
            font-size: 13px;
            margin: 5px 0;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .color-picker-button:hover {
            background-color: #555;
        }

        .color-picker-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .color-picker-popup.active {
            display: block;
        }

        .color-picker-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .color-picker-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .color-picker-title {
            color: white;
            margin-bottom: 15px;
            text-align: center;
        }

        .brush-controls {
            display: flex;
            gap: 5px;
            margin: 5px 0;
            align-items: center;
            justify-content: center;
        }

        .brush-controls label {
            margin-right: 5px;
            font-size: 14px;
        }

        input[type="range"] {
            width: 150px;
        }

        button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #555;
        }

        button.active {
            background-color: #666;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        #poison {
            background-color: #800080;
        }

        .chat-input {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .chat-input input {
            flex-grow: 1;
            padding: 8px;
            border: none;
            border-radius: 3px;
            background-color: #333;
            color: white;
        }

        .chat-input button {
            padding: 8px 15px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .chat-input button:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
    <h1>Falling Sand Game</h1>
    <div class="controls">
        <button id="wall" class="active">Wall</button>
        <button id="sand">Sand</button>
        <button id="water">Water</button>
        <button id="fire">Fire</button>
        <button id="plant">Plant</button>
        <button id="spout">Spout</button>
        <button id="oil">Oil</button>
        <button id="poison">Poison</button>
        <button id="fungus">Fungus</button>
        <button id="nanobot">Nanobot</button>
        <button id="cryo">Cryo</button>
        <button id="lava">Lava</button>
        <button id="acid">Acid</button>
        <button id="clearCanvas">Clear Canvas</button>
    </div>
    <div style="display: flex; gap: 10px;">
        <button class="color-picker-button">Change Background Color</button>
        <button class="theme-picker-button">Change Theme</button>
    </div>
    <div class="theme-picker-popup">
        <button class="theme-picker-close">×</button>
        <h3 class="theme-picker-title">Select Theme</h3>
        <div class="theme-picker-grid">
            <div class="theme-option active" data-theme="dark">
                <div class="theme-preview" style="background: linear-gradient(45deg, #1a1a1a, #2a2a2a);">Dark Theme</div>
                <div class="theme-name">Dark</div>
            </div>
            <div class="theme-option" data-theme="light">
                <div class="theme-preview" style="background: linear-gradient(45deg, #f5f5f5, #e0e0e0); color: #333;">Light Theme</div>
                <div class="theme-name">Light</div>
            </div>
            <div class="theme-option" data-theme="ocean">
                <div class="theme-preview" style="background: linear-gradient(45deg, #1e3c72, #2a5298);">Ocean Theme</div>
                <div class="theme-name">Ocean</div>
            </div>
            <div class="theme-option" data-theme="forest">
                <div class="theme-preview" style="background: linear-gradient(45deg, #1a472a, #2d5a27);">Forest Theme</div>
                <div class="theme-name">Forest</div>
            </div>
            <div class="theme-option" data-theme="sunset">
                <div class="theme-preview" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">Sunset Theme</div>
                <div class="theme-name">Sunset</div>
            </div>
            <div class="theme-option" data-theme="space">
                <div class="theme-preview" style="background: linear-gradient(45deg, #0f0c29, #302b63);">Space Theme</div>
                <div class="theme-name">Space</div>
            </div>
        </div>
    </div>
    <div class="color-picker-popup">
        <button class="color-picker-close">×</button>
        <h3 class="color-picker-title">Select Background Color</h3>
        <div class="color-picker-grid">
            <div class="color-option" style="background-color: #000000;" data-color="#000000"></div>
            <div class="color-option" style="background-color: #1a1a1a;" data-color="#1a1a1a"></div>
            <div class="color-option" style="background-color: #333333;" data-color="#333333"></div>
            <div class="color-option" style="background-color: #4d4d4d;" data-color="#4d4d4d"></div>
            <div class="color-option" style="background-color: #666666;" data-color="#666666"></div>
            <div class="color-option" style="background-color: #800000;" data-color="#800000"></div>
            <div class="color-option" style="background-color: #008000;" data-color="#008000"></div>
            <div class="color-option" style="background-color: #000080;" data-color="#000080"></div>
            <div class="color-option" style="background-color: #808000;" data-color="#808000"></div>
            <div class="color-option" style="background-color: #800080;" data-color="#800080"></div>
        </div>
    </div>
    <div class="brush-controls">
        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="20" value="1">
        <span id="brushSizeValue">1</span>
    </div>
    <div class="game-container">
        <canvas id="canvas"></canvas>
        <div class="chat-container">
            <div class="chat-header">
                <h3>Element Ideas</h3>
                <button class="export-button" id="exportButton">Export Comments</button>
            </div>
            <div class="chat-box" id="chatBox">
                <div class="active-comments">
                    <!-- Active comments will be here -->
                </div>
            </div>
            <div class="hidden-comments-section">
                <div class="hidden-comments-header" id="hiddenCommentsHeader">
                    <span>Hidden Comments</span>
                    <span class="hidden-count">(0)</span>
                </div>
                <div class="hidden-comments-content" id="hiddenCommentsContent">
                    <!-- Hidden comments will be here -->
                </div>
            </div>
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Suggest a new element...">
                <button id="sendButton">Send</button>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const CELL_SIZE = 2;
        const FPS = 60;
        const PARTICLE_TYPES = {
            EMPTY: 0,
            WALL: 1,
            SAND: 2,
            WATER: 3,
            FIRE: 4,
            PLANT: 5,
            SPOUT: 6,
            OIL: 7,
            POISON: 8,
            DUST: 9,
            FUNGUS: 10,
            NANOBOT: 11,
            CRYO: 12,
            ICE: 13,
            LAVA: 14,
            STONE: 15,
            ACID: 16
        };

        // Game state
        let canvas, ctx;
        let grid = [];
        let fireCooldowns = []; // Track fire particle cooldowns
        let plantHeatTimers = []; // Track plant heat build-up timers
        let oilHeatTimers = []; // Track oil heat build-up timers
        let poisonTimers = []; // Track plant poisoning timers
        let poisonStates = []; // Track poison particle states (active/transforming)
        let dustTimers = []; // Track dust particle lifetimes
        let nanobotDirections = []; // Track nanobot movement directions
        let nanobotCount = 0; // Track total number of nanobots
        let lavaCoolingTimers = []; // Track lava cooling timers
        let acidCorrosionTimers = []; // Track acid corrosion timers
        let iceEvaporationTimers = []; // Track ice evaporation timers
        const MAX_NANOBOTS = 200; // Maximum number of nanobots allowed
        let nanobotSwarmCenter = [0, 0]; // Track the center of the nanobot swarm
        let currentTool = PARTICLE_TYPES.WALL;
        let isDrawing = false;
        let isErasing = false;
        let brushSize = 1;
        let lastX = -1;
        let lastY = -1;
        let spoutTimer = 0;
        let backgroundColor = '#000000'; // Default background color

        // Theme configuration
        const themes = {
            dark: {
                '--bg-primary': '#1a1a1a',
                '--bg-secondary': '#2a2a2a',
                '--bg-tertiary': '#333',
                '--text-primary': '#ffffff',
                '--text-secondary': '#cccccc',
                '--accent-primary': '#444',
                '--accent-hover': '#555',
                '--border-color': '#333',
                '--canvas-border': '#333',
                '--chat-bg': '#2a2a2a',
                '--chat-border': '#333',
                '--button-radius': '5px',
                '--shadow-color': 'rgba(0, 0, 0, 0.5)',
                '--element-shadow': '0 0 5px rgba(255, 255, 255, 0.5)'
            },
            light: {
                '--bg-primary': '#f5f5f5',
                '--bg-secondary': '#e0e0e0',
                '--bg-tertiary': '#d0d0d0',
                '--text-primary': '#333333',
                '--text-secondary': '#666666',
                '--accent-primary': '#cccccc',
                '--accent-hover': '#bbbbbb',
                '--border-color': '#999999',
                '--canvas-border': '#999999',
                '--chat-bg': '#e0e0e0',
                '--chat-border': '#999999',
                '--button-radius': '5px',
                '--shadow-color': 'rgba(0, 0, 0, 0.2)',
                '--element-shadow': '0 0 5px rgba(0, 0, 0, 0.2)'
            },
            ocean: {
                '--bg-primary': '#1e3c72',
                '--bg-secondary': '#2a5298',
                '--bg-tertiary': '#3b6cb7',
                '--text-primary': '#ffffff',
                '--text-secondary': '#e0e0e0',
                '--accent-primary': '#4a90e2',
                '--accent-hover': '#357abd',
                '--border-color': '#2a5298',
                '--canvas-border': '#2a5298',
                '--chat-bg': '#2a5298',
                '--chat-border': '#3b6cb7',
                '--button-radius': '5px',
                '--shadow-color': 'rgba(0, 0, 0, 0.3)',
                '--element-shadow': '0 0 5px rgba(74, 144, 226, 0.5)'
            },
            forest: {
                '--bg-primary': '#1a472a',
                '--bg-secondary': '#2d5a27',
                '--bg-tertiary': '#3d7d3d',
                '--text-primary': '#ffffff',
                '--text-secondary': '#e0e0e0',
                '--accent-primary': '#4caf50',
                '--accent-hover': '#3d8b40',
                '--border-color': '#2d5a27',
                '--canvas-border': '#2d5a27',
                '--chat-bg': '#2d5a27',
                '--chat-border': '#3d7d3d',
                '--button-radius': '5px',
                '--shadow-color': 'rgba(0, 0, 0, 0.3)',
                '--element-shadow': '0 0 5px rgba(76, 175, 80, 0.5)'
            },
            sunset: {
                '--bg-primary': '#ff6b6b',
                '--bg-secondary': '#ff8e8e',
                '--bg-tertiary': '#ffa5a5',
                '--text-primary': '#ffffff',
                '--text-secondary': '#ffe0e0',
                '--accent-primary': '#ff5252',
                '--accent-hover': '#ff4040',
                '--border-color': '#ff8e8e',
                '--canvas-border': '#ff8e8e',
                '--chat-bg': '#ff8e8e',
                '--chat-border': '#ffa5a5',
                '--button-radius': '5px',
                '--shadow-color': 'rgba(0, 0, 0, 0.2)',
                '--element-shadow': '0 0 5px rgba(255, 255, 255, 0.5)'
            },
            space: {
                '--bg-primary': '#0f0c29',
                '--bg-secondary': '#302b63',
                '--bg-tertiary': '#24243e',
                '--text-primary': '#ffffff',
                '--text-secondary': '#e0e0e0',
                '--accent-primary': '#4a148c',
                '--accent-hover': '#6a1b9a',
                '--border-color': '#302b63',
                '--canvas-border': '#302b63',
                '--chat-bg': '#302b63',
                '--chat-border': '#24243e',
                '--button-radius': '5px',
                '--shadow-color': 'rgba(0, 0, 0, 0.4)',
                '--element-shadow': '0 0 5px rgba(148, 0, 211, 0.5)'
            }
        };

        // Initialize the game
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Set canvas size based on device
            function resizeCanvas() {
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    // For mobile, use 90% of screen width and 50% of screen height
                    canvas.width = Math.floor(window.innerWidth * 0.9);
                    canvas.height = Math.floor(window.innerHeight * 0.5);
                } else {
                    // For desktop, use original sizing
                    canvas.width = Math.floor(window.innerWidth * 0.5);
                    canvas.height = Math.floor(window.innerHeight * 0.7);
                }

                // Reinitialize grid and other arrays with new dimensions
                const cols = Math.floor(canvas.width / CELL_SIZE);
                const rows = Math.floor(canvas.height / CELL_SIZE);
                
                grid = Array(rows).fill().map(() => Array(cols).fill(PARTICLE_TYPES.EMPTY));
                fireCooldowns = Array(rows).fill().map(() => Array(cols).fill(0));
                plantHeatTimers = Array(rows).fill().map(() => Array(cols).fill(0));
                oilHeatTimers = Array(rows).fill().map(() => Array(cols).fill(0));
                poisonTimers = Array(rows).fill().map(() => Array(cols).fill(0));
                poisonStates = Array(rows).fill().map(() => Array(cols).fill(0));
                dustTimers = Array(rows).fill().map(() => Array(cols).fill(0));
                nanobotDirections = Array(rows).fill().map(() => Array(cols).fill([0, 0]));
                lavaCoolingTimers = Array(rows).fill().map(() => Array(cols).fill(0));
                acidCorrosionTimers = Array(rows).fill().map(() => Array(cols).fill(0));
                iceEvaporationTimers = Array(rows).fill().map(() => Array(cols).fill(0));
            }

            // Initial resize
            resizeCanvas();

            // Add resize listener
            window.addEventListener('resize', resizeCanvas);

            // Event listeners for both mouse and touch
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Prevent context menu on right click
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Brush size control
            const brushSizeInput = document.getElementById('brushSize');
            const brushSizeValue = document.getElementById('brushSizeValue');
            brushSizeInput.addEventListener('input', () => {
                brushSize = parseInt(brushSizeInput.value);
                brushSizeValue.textContent = brushSize;
            });

            // Tool selection buttons
            document.querySelectorAll('.controls button').forEach(button => {
                button.addEventListener('click', () => {
                    if (button.id === 'clearCanvas') {
                        clearCanvas();
                        return;
                    }
                    document.querySelector('.active')?.classList.remove('active');
                    button.classList.add('active');
                    currentTool = PARTICLE_TYPES[button.id.toUpperCase()];
                });
            });

            // Load saved theme
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);

            // Set up theme picker event listeners
            const themePickerButton = document.querySelector('.theme-picker-button');
            const themePickerPopup = document.querySelector('.theme-picker-popup');
            const themePickerClose = document.querySelector('.theme-picker-close');

            themePickerButton.addEventListener('click', () => {
                themePickerPopup.classList.add('active');
            });

            themePickerClose.addEventListener('click', () => {
                themePickerPopup.classList.remove('active');
            });

            // Close popup when clicking outside
            document.addEventListener('click', (e) => {
                if (!themePickerPopup.contains(e.target) && e.target !== themePickerButton) {
                    themePickerPopup.classList.remove('active');
                }
            });

            document.querySelectorAll('.theme-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Remove active class from all options
                    document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
                    // Add active class to clicked option
                    option.classList.add('active');
                    // Apply the selected theme
                    const theme = option.dataset.theme;
                    applyTheme(theme);
                    // Save theme preference
                    localStorage.setItem('theme', theme);
                    // Close the popup
                    themePickerPopup.classList.remove('active');
                });
            });

            // Set up color picker event listeners
            const colorPickerButton = document.querySelector('.color-picker-button');
            const colorPickerPopup = document.querySelector('.color-picker-popup');
            const colorPickerClose = document.querySelector('.color-picker-close');

            colorPickerButton.addEventListener('click', () => {
                colorPickerPopup.classList.add('active');
            });

            colorPickerClose.addEventListener('click', () => {
                colorPickerPopup.classList.remove('active');
            });

            // Close popup when clicking outside
            document.addEventListener('click', (e) => {
                if (!colorPickerPopup.contains(e.target) && e.target !== colorPickerButton) {
                    colorPickerPopup.classList.remove('active');
                }
            });

            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Remove active class from all options
                    document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('active'));
                    // Add active class to clicked option
                    option.classList.add('active');
                    // Set the background color
                    backgroundColor = option.dataset.color;
                    // Close the popup
                    colorPickerPopup.classList.remove('active');
                });
            });

            // Start game loop
            setInterval(update, 1000 / FPS);
        }

        // Touch event handlers
        function handleTouchStart(e) {
            e.preventDefault(); // Prevent scrolling
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((touch.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((touch.clientY - rect.top) / CELL_SIZE);
            
            isDrawing = true;
            isErasing = false;
            lastX = x;
            lastY = y;
            handleTouchMove(e);
        }

        function handleTouchMove(e) {
            e.preventDefault(); // Prevent scrolling
            if (!isDrawing) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((touch.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((touch.clientY - rect.top) / CELL_SIZE);

            if (x >= 0 && x < grid[0].length && y >= 0 && y < grid.length) {
                drawLine(lastX, lastY, x, y);
                lastX = x;
                lastY = y;
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            isDrawing = false;
            isErasing = false;
            lastX = -1;
            lastY = -1;
        }

        // Handle mouse events
        function handleMouseDown(e) {
            isDrawing = e.button === 0;
            isErasing = e.button === 2;
            lastX = -1;
            lastY = -1;
            handleMouseMove(e);
        }

        function handleMouseMove(e) {
            if (!isDrawing && !isErasing) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

            if (x >= 0 && x < grid[0].length && y >= 0 && y < grid.length) {
                // Always draw at current position
                drawLine(x, y, x, y);
                
                // If we have a last position, also draw a line between points
                if (lastX !== -1 && lastY !== -1) {
                    drawLine(lastX, lastY, x, y);
                }
                
                lastX = x;
                lastY = y;
            }
        }

        function drawLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                // Draw brush circle at current position
                for (let by = -Math.floor(brushSize/2); by <= Math.floor(brushSize/2); by++) {
                    for (let bx = -Math.floor(brushSize/2); bx <= Math.floor(brushSize/2); bx++) {
                        const nx = x0 + bx;
                        const ny = y0 + by;
                        if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length) {
                            if (isErasing) {
                                grid[ny][nx] = PARTICLE_TYPES.EMPTY;
                            } else if (currentTool === PARTICLE_TYPES.FIRE) {
                                // Special handling for fire to create floating flames
                                if (ny >= 0 && ny < grid.length) {
                                    // Place fire at cursor position
                                    grid[ny][nx] = PARTICLE_TYPES.FIRE;
                                    
                                    // Add additional fire particles above the cursor
                                    const flameHeight = Math.floor(brushSize * 4); // Increased from 2.25 to 4 for taller flames
                                    for (let fy = 1; fy <= flameHeight; fy++) {
                                        // Only add fire particles with decreasing probability as height increases
                                        if (Math.random() < 0.8 - (fy * 0.15)) { // Increased base probability from 0.7 to 0.8
                                            const flameY = ny - fy;
                                            if (flameY >= 0 && flameY < grid.length) {
                                                // Add some horizontal variation to the flames
                                                const flameX = nx + Math.floor(Math.random() * 3) - 1;
                                                if (flameX >= 0 && flameX < grid[0].length) {
                                                    grid[flameY][flameX] = PARTICLE_TYPES.FIRE;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else if (currentTool === PARTICLE_TYPES.NANOBOT) {
                                // Special handling for nanobots to respect the maximum count
                                if (nanobotCount < MAX_NANOBOTS) {
                                    grid[ny][nx] = PARTICLE_TYPES.NANOBOT;
                                    nanobotCount++;
                                }
                            } else {
                                grid[ny][nx] = currentTool;
                            }
                        }
                    }
                }

                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        function handleMouseUp() {
            isDrawing = false;
            isErasing = false;
            lastX = -1;
            lastY = -1;
        }

        // Update particle positions
        function update() {
            const rows = grid.length;
            const cols = grid[0].length;

            // Process particles from bottom to top for proper falling behavior
            for (let y = rows - 1; y >= 0; y--) {
                // Process columns in alternating order to avoid bias
                const cols = Array.from({length: grid[0].length}, (_, i) => i);
                if (y % 2 === 0) {
                    cols.reverse();
                }

                for (const x of cols) {
                    const particle = grid[y][x];
                    
                    switch (particle) {
                        case PARTICLE_TYPES.SAND:
                            updateSand(x, y);
                            break;
                        case PARTICLE_TYPES.WATER:
                            updateWater(x, y);
                            break;
                        case PARTICLE_TYPES.FIRE:
                            updateFire(x, y);
                            break;
                        case PARTICLE_TYPES.PLANT:
                            updatePlant(x, y);
                            break;
                        case PARTICLE_TYPES.OIL:
                            updateOil(x, y);
                            break;
                        case PARTICLE_TYPES.POISON:
                            updatePoison(x, y);
                            break;
                        case PARTICLE_TYPES.DUST:
                            updateDust(x, y);
                            break;
                        case PARTICLE_TYPES.FUNGUS:
                            updateFungus(x, y);
                            break;
                        case PARTICLE_TYPES.NANOBOT:
                            updateNanobot(x, y);
                            break;
                        case PARTICLE_TYPES.CRYO:
                            updateCryo(x, y);
                            break;
                        case PARTICLE_TYPES.ICE:
                            updateIce(x, y);
                            break;
                        case PARTICLE_TYPES.LAVA:
                            updateLava(x, y);
                            break;
                        case PARTICLE_TYPES.ACID:
                            updateAcid(x, y);
                            break;
                    }
                }
            }

            // Update spouts
            updateSpouts();

            // Update all timers
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (fireCooldowns[y][x] > 0) {
                        fireCooldowns[y][x]--;
                    }
                    // Update plant heat timers
                    if (plantHeatTimers[y][x] > 0) {
                        plantHeatTimers[y][x]--;
                        if (plantHeatTimers[y][x] === 0 && (grid[y][x] === PARTICLE_TYPES.PLANT || grid[y][x] === PARTICLE_TYPES.FUNGUS)) {
                            grid[y][x] = PARTICLE_TYPES.FIRE;
                            fireCooldowns[y][x] = 15;
                        }
                    }
                    // Update oil heat timers
                    if (oilHeatTimers[y][x] > 0) {
                        oilHeatTimers[y][x]--;
                        if (oilHeatTimers[y][x] === 0 && grid[y][x] === PARTICLE_TYPES.OIL) {
                            grid[y][x] = PARTICLE_TYPES.FIRE;
                            fireCooldowns[y][x] = 15;
                        }
                    }
                    // Update poison timers
                    if (poisonTimers[y][x] > 0) {
                        poisonTimers[y][x]--;
                        if (poisonTimers[y][x] === 0) {
                            if (grid[y][x] === PARTICLE_TYPES.PLANT) {
                                // Transform plant into dust
                                grid[y][x] = PARTICLE_TYPES.DUST;
                                dustTimers[y][x] = Math.floor(Math.random() * 30) + 30; // 30-60 frames (0.5-1 second)
                            } else if (grid[y][x] === PARTICLE_TYPES.POISON && poisonStates[y][x] === 1) {
                                // Transform poison into dust
                                grid[y][x] = PARTICLE_TYPES.DUST;
                                dustTimers[y][x] = Math.floor(Math.random() * 30) + 30; // 30-60 frames (0.5-1 second)
                                poisonStates[y][x] = 0;
                            }
                        }
                    }
                    // Update dust timers
                    if (dustTimers[y][x] > 0) {
                        dustTimers[y][x]--;
                        if (dustTimers[y][x] === 0 && grid[y][x] === PARTICLE_TYPES.DUST) {
                            grid[y][x] = PARTICLE_TYPES.EMPTY;
                        }
                    }
                    // Update acid corrosion timers
                    if (acidCorrosionTimers[y][x] > 0) {
                        acidCorrosionTimers[y][x]--;
                        if (acidCorrosionTimers[y][x] === 0) {
                            // Corrode the particle
                            grid[y][x] = PARTICLE_TYPES.EMPTY;
                        }
                    }
                    // Update ice evaporation timers
                    if (iceEvaporationTimers[y][x] > 0) {
                        iceEvaporationTimers[y][x]--;
                        if (iceEvaporationTimers[y][x] === 0) {
                            // Completely evaporate
                            grid[y][x] = PARTICLE_TYPES.EMPTY;
                            return;
                        }
                    }
                }
            }

            // Recalculate nanobot count
            nanobotCount = 0;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x] === PARTICLE_TYPES.NANOBOT) {
                        nanobotCount++;
                    }
                }
            }

            draw();
        }

        // Update sand particle
        function updateSand(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Try to move down with minimal horizontal movement
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                // Very slight random drift for natural look
                const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y + 1][x + drift] = PARTICLE_TYPES.SAND;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                } else {
                    grid[y + 1][x] = PARTICLE_TYPES.SAND;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                }
                return;
            }

            // Try to move diagonally with minimal spread
            const direction = Math.random() < 0.5 ? -1 : 1;
            if (x + direction >= 0 && x + direction < grid[0].length &&
                grid[y + 1][x + direction] === PARTICLE_TYPES.EMPTY) {
                grid[y + 1][x + direction] = PARTICLE_TYPES.SAND;
                grid[y][x] = PARTICLE_TYPES.EMPTY;
            }
        }

        // Update water particle
        function updateWater(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Try to move down with minimal horizontal movement
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                // Very slight random drift for natural look
                const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y + 1][x + drift] = PARTICLE_TYPES.WATER;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                } else {
                    grid[y + 1][x] = PARTICLE_TYPES.WATER;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                }
                return;
            }

            // Enhanced horizontal movement with minimal spread
            const maxSpread = 1; // Reduced to 1 for more controlled flow
            const direction = Math.random() < 0.5 ? -1 : 1;
            let moved = false;

            // Try multiple horizontal positions
            for (let spread = 1; spread <= maxSpread; spread++) {
                const testX = x + (direction * spread);
                if (testX >= 0 && testX < grid[0].length) {
                    if (grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                        if (Math.random() < 0.2 && y + 1 < grid.length && grid[y + 1][testX] === PARTICLE_TYPES.EMPTY) {
                            grid[y + 1][testX] = PARTICLE_TYPES.WATER;
                        } else {
                            grid[y][testX] = PARTICLE_TYPES.WATER;
                        }
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        moved = true;
                        break;
                    }
                }
            }

            // If couldn't move horizontally, try the other direction
            if (!moved && Math.random() < 0.5) {
                const altDirection = -direction;
                const testX = x + altDirection;
                if (testX >= 0 && testX < grid[0].length && grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                    grid[y][testX] = PARTICLE_TYPES.WATER;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                }
            }
        }

        // Update fire particle
        function updateFire(x, y) {
            if (y <= 0) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                fireCooldowns[y][x] = 0;
                return;
            }

            // Check for water to extinguish
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.WATER) {
                            grid[y][x] = PARTICLE_TYPES.EMPTY;
                            fireCooldowns[y][x] = 0;
                            return;
                        }
                    }
                }
            }

            // Random chance to extinguish with height-based probability
            const heightFactor = 1 - (y / grid.length);
            if (Math.random() < 0.1 + (heightFactor * 0.2)) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                fireCooldowns[y][x] = 0;
                return;
            }

            // Try to move up with minimal horizontal drift
            const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
            let moved = false;

            // Try moving up with drift
            if (y - 1 >= 0 && x + drift >= 0 && x + drift < grid[0].length) {
                if (grid[y - 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y - 1][x + drift] = PARTICLE_TYPES.FIRE;
                    fireCooldowns[y - 1][x + drift] = fireCooldowns[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    fireCooldowns[y][x] = 0;
                    moved = true;
                }
            }

            // If couldn't move up with drift, try just moving up
            if (!moved && y - 1 >= 0 && grid[y - 1][x] === PARTICLE_TYPES.EMPTY) {
                grid[y - 1][x] = PARTICLE_TYPES.FIRE;
                fireCooldowns[y - 1][x] = fireCooldowns[y][x];
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                fireCooldowns[y][x] = 0;
                return;
            }

            // Only attempt to spread if cooldown is 0
            if (fireCooldowns[y][x] === 0) {
                // 20% chance to attempt spreading (increased from 10%)
                if (Math.random() < 0.2) {
                    const directions = [
                        [0, -1],  // Up
                        [-1, 0],  // Left
                        [1, 0],   // Right
                        [0, 1],   // Down
                        [-1, -1], // Diagonals
                        [1, -1],
                        [-1, 1],
                        [1, 1]
                    ];
                    shuffleArray(directions);

                    // Try each direction until we find something to burn
                    for (const [dy, dx] of directions) {
                        const ny = y + dy;
                        const nx = x + dx;
                        if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                            const targetType = grid[ny][nx];
                            if (targetType === PARTICLE_TYPES.SAND || targetType === PARTICLE_TYPES.WALL) {
                                grid[ny][nx] = PARTICLE_TYPES.FIRE;
                                fireCooldowns[ny][nx] = 10; // Reduced cooldown from 15 to 10
                                break;
                            }
                            // Plants are now handled by the heat build-up system in updatePlant
                        }
                    }
                    // Set cooldown for this fire particle
                    fireCooldowns[y][x] = 10; // Reduced cooldown from 15 to 10
                }
            }
        }

        // Update plant particle
        function updatePlant(x, y) {
            // Check for fire to start heat build-up
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.FIRE && plantHeatTimers[y][x] === 0) {
                            // Start heat build-up with random duration between 5-10 frames (reduced from 15-30)
                            plantHeatTimers[y][x] = Math.floor(Math.random() * 6) + 5;
                            break;
                        }
                    }
                }
            }

            // Try to convert adjacent water into plants
            if (Math.random() < 0.075) { // 7.5% chance to attempt growth each frame
                const directions = [
                    [0, -1],  // Up
                    [-1, 0],  // Left
                    [1, 0],   // Right
                    [0, 1],   // Down
                    [-1, -1], // Diagonals
                    [1, -1],
                    [-1, 1],
                    [1, 1]
                ];
                shuffleArray(directions);

                // Try each direction until we find water to convert
                for (const [dy, dx] of directions) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        // Check if the target cell is water and not adjacent to a spout
                        if (grid[ny][nx] === PARTICLE_TYPES.WATER) {
                            // Check surrounding cells for spouts
                            let hasAdjacentSpout = false;
                            for (let sy = -1; sy <= 1; sy++) {
                                for (let sx = -1; sx <= 1; sx++) {
                                    const spy = ny + sy;
                                    const spx = nx + sx;
                                    if (spy >= 0 && spy < grid.length && spx >= 0 && spx < grid[0].length) {
                                        if (grid[spy][spx] === PARTICLE_TYPES.SPOUT) {
                                            hasAdjacentSpout = true;
                                            break;
                                        }
                                    }
                                }
                                if (hasAdjacentSpout) break;
                            }
                            
                            // Only grow if there's no adjacent spout
                            if (!hasAdjacentSpout) {
                                grid[ny][nx] = PARTICLE_TYPES.PLANT;
                                break;
                            }
                        }
                    }
                }
            }
        }

        // Update oil particle
        function updateOil(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Try to move down with minimal horizontal movement
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                // Very slight random drift for natural look
                const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y + 1][x + drift] = PARTICLE_TYPES.OIL;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                } else {
                    grid[y + 1][x] = PARTICLE_TYPES.OIL;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                }
                return;
            }

            // Check for fire to start heat build-up
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.FIRE && oilHeatTimers[y][x] === 0) {
                            // Start heat build-up with random duration between 3-8 frames (much faster than plants)
                            oilHeatTimers[y][x] = Math.floor(Math.random() * 6) + 3;
                            break;
                        }
                    }
                }
            }

            // Enhanced horizontal movement with minimal spread
            const maxSpread = 1; // Reduced to 1 for more controlled flow
            const direction = Math.random() < 0.5 ? -1 : 1;
            let moved = false;

            // Try multiple horizontal positions
            for (let spread = 1; spread <= maxSpread; spread++) {
                const testX = x + (direction * spread);
                if (testX >= 0 && testX < grid[0].length) {
                    if (grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                        if (Math.random() < 0.2 && y + 1 < grid.length && grid[y + 1][testX] === PARTICLE_TYPES.EMPTY) {
                            grid[y + 1][testX] = PARTICLE_TYPES.OIL;
                        } else {
                            grid[y][testX] = PARTICLE_TYPES.OIL;
                        }
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        moved = true;
                        break;
                    }
                }
            }

            // If couldn't move horizontally, try the other direction
            if (!moved && Math.random() < 0.5) {
                const altDirection = -direction;
                const testX = x + altDirection;
                if (testX >= 0 && testX < grid[0].length && grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                    grid[y][testX] = PARTICLE_TYPES.OIL;
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                }
            }
        }

        // Update poison particle
        function updatePoison(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Check for plants to poison
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.PLANT && poisonTimers[ny][nx] === 0) {
                            // Start poisoning with random duration between 5-10 frames
                            poisonTimers[ny][nx] = Math.floor(Math.random() * 6) + 5;
                            break;
                        }
                    }
                }
            }

            // Try to move down first (gravity)
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                // Very slight random drift for natural look
                const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y + 1][x + drift] = PARTICLE_TYPES.POISON;
                    poisonStates[y + 1][x + drift] = poisonStates[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    poisonStates[y][x] = 0;
                } else {
                    grid[y + 1][x] = PARTICLE_TYPES.POISON;
                    poisonStates[y + 1][x] = poisonStates[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    poisonStates[y][x] = 0;
                }
                return;
            }

            // Only attempt horizontal movement every other frame
            if (Math.random() < 0.5) return;

            // Enhanced horizontal movement with minimal spread
            const maxSpread = 1;
            const direction = Math.random() < 0.5 ? -1 : 1;
            let moved = false;

            // Try multiple horizontal positions
            for (let spread = 1; spread <= maxSpread; spread++) {
                const testX = x + (direction * spread);
                if (testX >= 0 && testX < grid[0].length) {
                    if (grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                        if (Math.random() < 0.2 && y + 1 < grid.length && grid[y + 1][testX] === PARTICLE_TYPES.EMPTY) {
                            grid[y + 1][testX] = PARTICLE_TYPES.POISON;
                            poisonStates[y + 1][testX] = poisonStates[y][x];
                        } else {
                            grid[y][testX] = PARTICLE_TYPES.POISON;
                            poisonStates[y][testX] = poisonStates[y][x];
                        }
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        poisonStates[y][x] = 0;
                        moved = true;
                        break;
                    }
                }
            }

            // If couldn't move horizontally, try the other direction
            if (!moved && Math.random() < 0.5) {
                const altDirection = -direction;
                const testX = x + altDirection;
                if (testX >= 0 && testX < grid[0].length && grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                    grid[y][testX] = PARTICLE_TYPES.POISON;
                    poisonStates[y][testX] = poisonStates[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    poisonStates[y][x] = 0;
                }
            }
        }

        // Update dust particle
        function updateDust(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Dust falls very slowly and drifts
            if (Math.random() < 0.3) { // Only move 30% of the time
                if (y + 1 < grid.length && grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                    const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                    if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                        grid[y + 1][x + drift] = PARTICLE_TYPES.DUST;
                        dustTimers[y + 1][x + drift] = dustTimers[y][x]; // Transfer the timer
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        dustTimers[y][x] = 0;
                    } else {
                        grid[y + 1][x] = PARTICLE_TYPES.DUST;
                        dustTimers[y + 1][x] = dustTimers[y][x]; // Transfer the timer
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        dustTimers[y][x] = 0;
                    }
                }
            }
        }

        // Update fungus particle
        function updateFungus(x, y) {
            // Check for fire to start heat build-up (fungus can burn like plants)
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.FIRE && plantHeatTimers[y][x] === 0) {
                            // Start heat build-up with random duration between 15-30 frames
                            plantHeatTimers[y][x] = Math.floor(Math.random() * 16) + 15;
                            break;
                        }
                    }
                }
            }

            // Try to convert adjacent oil and poison into fungus
            if (Math.random() < 0.075) { // 7.5% chance to attempt growth each frame
                const directions = [
                    [0, -1],  // Up
                    [-1, 0],  // Left
                    [1, 0],   // Right
                    [0, 1],   // Down
                    [-1, -1], // Diagonals
                    [1, -1],
                    [-1, 1],
                    [1, 1]
                ];
                shuffleArray(directions);

                // Try each direction until we find oil or poison to convert
                for (const [dy, dx] of directions) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.OIL || grid[ny][nx] === PARTICLE_TYPES.POISON) {
                            grid[ny][nx] = PARTICLE_TYPES.FUNGUS;
                            break;
                        }
                    }
                }
            }
        }

        // Update nanobot particle
        function updateNanobot(x, y) {
            // Skip if we've reached the maximum number of nanobots
            if (nanobotCount >= MAX_NANOBOTS) {
                // Just move the nanobot without creating new ones
                let [dx, dy] = nanobotDirections[y][x];
                if (dx === 0 && dy === 0) {
                    // Initialize with a random direction
                    const angle = Math.random() * Math.PI * 2;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                    nanobotDirections[y][x] = [dx, dy];
                }
                
                // Add some randomness to the movement (flutter effect)
                dx += (Math.random() - 0.5) * 0.5;
                dy += (Math.random() - 0.5) * 0.5;
                
                // Normalize the direction vector
                const length = Math.sqrt(dx * dx + dy * dy);
                if (length > 0) {
                    dx /= length;
                    dy /= length;
                } else {
                    // If length is zero, set a random direction
                    const angle = Math.random() * Math.PI * 2;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                }
                
                // Look for nearby particles to consume (within a 5-cell radius)
                const searchRadius = 5;
                let targetFound = false;
                let targetX = -1;
                let targetY = -1;
                let minDistance = Infinity;
                
                // Search in a spiral pattern from the center outward
                for (let r = 1; r <= searchRadius && !targetFound; r++) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                        const checkX = Math.round(x + Math.cos(angle) * r);
                        const checkY = Math.round(y + Math.sin(angle) * r);
                        
                        if (checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length) {
                            const particle = grid[checkY][checkX];
                            if (particle !== PARTICLE_TYPES.EMPTY && particle !== PARTICLE_TYPES.NANOBOT && particle !== PARTICLE_TYPES.WALL) {
                                // Calculate distance to this particle
                                const distance = Math.sqrt((checkX - x) ** 2 + (checkY - y) ** 2);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    targetX = checkX;
                                    targetY = checkY;
                                    targetFound = true;
                                }
                            }
                        }
                    }
                }
                
                // If a target was found, move towards it
                if (targetFound) {
                    // Calculate direction to target
                    const targetDx = targetX - x;
                    const targetDy = targetY - y;
                    const targetLength = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                    
                    // Blend current direction with target direction (70% current, 30% target)
                    dx = dx * 0.7 + (targetDx / targetLength) * 0.3;
                    dy = dy * 0.7 + (targetDy / targetLength) * 0.3;
                    
                    // Normalize again
                    const newLength = Math.sqrt(dx * dx + dy * dy);
                    if (newLength > 0) {
                        dx /= newLength;
                        dy /= newLength;
                    }
                    
                    // Update direction
                    nanobotDirections[y][x] = [dx, dy];
                    
                    // Try to move in the calculated direction
                    const newX = Math.round(x + dx);
                    const newY = Math.round(y + dy);
                    
                    if (newX >= 0 && newX < grid[0].length && newY >= 0 && newY < grid.length) {
                        // If the target cell is empty, move there
                        if (grid[newY][newX] === PARTICLE_TYPES.EMPTY) {
                            grid[newY][newX] = PARTICLE_TYPES.NANOBOT;
                            nanobotDirections[newY][newX] = nanobotDirections[y][x];
                            grid[y][x] = PARTICLE_TYPES.EMPTY;
                            nanobotDirections[y][x] = [0, 0];
                        } 
                        // If the target cell has a consumable particle, consume it
                        else if (grid[newY][newX] !== PARTICLE_TYPES.NANOBOT && grid[newY][newX] !== PARTICLE_TYPES.WALL) {
                            // Consume the particle (delete it)
                            grid[newY][newX] = PARTICLE_TYPES.EMPTY;
                        }
                    }
                } else {
                    // Try to move in the calculated direction
                    const newX = Math.round(x + dx);
                    const newY = Math.round(y + dy);
                    
                    if (newX >= 0 && newX < grid[0].length && newY >= 0 && newY < grid.length) {
                        if (grid[newY][newX] === PARTICLE_TYPES.EMPTY) {
                            grid[newY][newX] = PARTICLE_TYPES.NANOBOT;
                            nanobotDirections[newY][newX] = nanobotDirections[y][x];
                            grid[y][x] = PARTICLE_TYPES.EMPTY;
                            nanobotDirections[y][x] = [0, 0];
                        }
                    } else {
                        // Hit a boundary, change direction
                        nanobotDirections[y][x] = [(Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2];
                    }
                }
                
                // Every 30 frames, do a global search for food
                if (Math.random() < 0.03) { // 3% chance each frame
                    // Look for food anywhere on the canvas
                    let globalFoodFound = false;
                    let globalFoodX = -1;
                    let globalFoodY = -1;
                    let globalFoodDistance = Infinity;
                    
                    // Search the entire canvas
                    for (let ny = 0; ny < grid.length; ny++) {
                        for (let nx = 0; nx < grid[0].length; nx++) {
                            const particle = grid[ny][nx];
                            if (particle !== PARTICLE_TYPES.EMPTY && particle !== PARTICLE_TYPES.NANOBOT && particle !== PARTICLE_TYPES.WALL) {
                                // Calculate distance to this particle
                                const distance = Math.sqrt((nx - x) ** 2 + (ny - y) ** 2);
                                if (distance < globalFoodDistance) {
                                    globalFoodDistance = distance;
                                    globalFoodX = nx;
                                    globalFoodY = ny;
                                    globalFoodFound = true;
                                }
                            }
                        }
                    }
                    
                    // If food found globally, move toward it
                    if (globalFoodFound) {
                        // Calculate direction to food
                        const foodDx = globalFoodX - x;
                        const foodDy = globalFoodY - y;
                        const foodLength = Math.sqrt(foodDx * foodDx + foodDy * foodDy);
                        
                        // Set direction toward food with higher weight (80% food, 20% current)
                        dx = dx * 0.2 + (foodDx / foodLength) * 0.8;
                        dy = dy * 0.2 + (foodDy / foodLength) * 0.8;
                        
                        // Normalize
                        const newLength = Math.sqrt(dx * dx + dy * dy);
                        if (newLength > 0) {
                            dx /= newLength;
                            dy /= newLength;
                        }
                        
                        // Update direction
                        nanobotDirections[y][x] = [dx, dy];
                    }
                }
                
                return;
            }
            
            // Get current direction or initialize a random one
            let [dx, dy] = nanobotDirections[y][x];
            if (dx === 0 && dy === 0) {
                // Initialize with a random direction
                const angle = Math.random() * Math.PI * 2;
                dx = Math.cos(angle);
                dy = Math.sin(angle);
                nanobotDirections[y][x] = [dx, dy];
            }
            
            // Add some randomness to the movement (flutter effect)
            dx += (Math.random() - 0.5) * 0.5;
            dy += (Math.random() - 0.5) * 0.5;
            
            // Normalize the direction vector
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length > 0) {
                dx /= length;
                dy /= length;
            } else {
                // If length is zero, set a random direction
                const angle = Math.random() * Math.PI * 2;
                dx = Math.cos(angle);
                dy = Math.sin(angle);
            }
            
            // Calculate swarm center (average position of all nanobots)
            let totalX = 0;
            let totalY = 0;
            let count = 0;
            
            for (let ny = 0; ny < grid.length; ny++) {
                for (let nx = 0; nx < grid[0].length; nx++) {
                    if (grid[ny][nx] === PARTICLE_TYPES.NANOBOT) {
                        totalX += nx;
                        totalY += ny;
                        count++;
                    }
                }
            }
            
            if (count > 0) {
                nanobotSwarmCenter = [totalX / count, totalY / count];
            }
            
            // Look for nearby particles to consume (within a 5-cell radius)
            const searchRadius = 5;
            let targetFound = false;
            let targetX = -1;
            let targetY = -1;
            let minDistance = Infinity;
            
            // Search in a spiral pattern from the center outward
            for (let r = 1; r <= searchRadius && !targetFound; r++) {
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                    const checkX = Math.round(x + Math.cos(angle) * r);
                    const checkY = Math.round(y + Math.sin(angle) * r);
                    
                    if (checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length) {
                        const particle = grid[checkY][checkX];
                        if (particle !== PARTICLE_TYPES.EMPTY && particle !== PARTICLE_TYPES.NANOBOT && particle !== PARTICLE_TYPES.WALL) {
                            // Calculate distance to this particle
                            const distance = Math.sqrt((checkX - x) ** 2 + (checkY - y) ** 2);
                            if (distance < minDistance) {
                                minDistance = distance;
                                targetX = checkX;
                                targetY = checkY;
                                targetFound = true;
                            }
                        }
                    }
                }
            }
            
            // If a target was found, move towards it
            if (targetFound) {
                // Calculate direction to target
                const targetDx = targetX - x;
                const targetDy = targetY - y;
                const targetLength = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                
                // Blend current direction with target direction (70% current, 30% target)
                dx = dx * 0.7 + (targetDx / targetLength) * 0.3;
                dy = dy * 0.7 + (targetDy / targetLength) * 0.3;
                
                // Normalize again
                const newLength = Math.sqrt(dx * dx + dy * dy);
                if (newLength > 0) {
                    dx /= newLength;
                    dy /= newLength;
                }
                
                // Update direction
                nanobotDirections[y][x] = [dx, dy];
                
                // Try to move in the calculated direction
                const newX = Math.round(x + dx);
                const newY = Math.round(y + dy);
                
                if (newX >= 0 && newX < grid[0].length && newY >= 0 && newY < grid.length) {
                    // If the target cell is empty, move there
                    if (grid[newY][newX] === PARTICLE_TYPES.EMPTY) {
                        grid[newY][newX] = PARTICLE_TYPES.NANOBOT;
                        nanobotDirections[newY][newX] = nanobotDirections[y][x];
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        nanobotDirections[y][x] = [0, 0];
                    } 
                    // If the target cell has a consumable particle, consume it
                    else if (grid[newY][newX] !== PARTICLE_TYPES.NANOBOT && grid[newY][newX] !== PARTICLE_TYPES.WALL) {
                        // Consume the particle (delete it)
                        grid[newY][newX] = PARTICLE_TYPES.EMPTY;
                    }
                }
            } else {
                // No target found, move with swarm behavior
                
                // Calculate direction to swarm center
                const swarmDx = nanobotSwarmCenter[0] - x;
                const swarmDy = nanobotSwarmCenter[1] - y;
                const swarmDist = Math.sqrt(swarmDx * swarmDx + swarmDy * swarmDy);
                
                // If too far from swarm center, move toward it
                if (swarmDist > 10) {
                    // Blend current direction with direction to swarm center (60% current, 40% swarm)
                    dx = dx * 0.6 + (swarmDx / swarmDist) * 0.4;
                    dy = dy * 0.6 + (swarmDy / swarmDist) * 0.4;
                } else {
                    // If close to swarm center, add some random movement to create swarm effect
                    dx += (Math.random() - 0.5) * 0.8;
                    dy += (Math.random() - 0.5) * 0.8;
                }
                
                // Normalize again
                const newLength = Math.sqrt(dx * dx + dy * dy);
                if (newLength > 0) {
                    dx /= newLength;
                    dy /= newLength;
                } else {
                    // If length is zero, set a random direction
                    const angle = Math.random() * Math.PI * 2;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                }
                
                // Update direction
                nanobotDirections[y][x] = [dx, dy];
                
                // Try to move in the calculated direction
                const newX = Math.round(x + dx);
                const newY = Math.round(y + dy);
                
                if (newX >= 0 && newX < grid[0].length && newY >= 0 && newY < grid.length) {
                    if (grid[newY][newX] === PARTICLE_TYPES.EMPTY) {
                        grid[newY][newX] = PARTICLE_TYPES.NANOBOT;
                        nanobotDirections[newY][newX] = nanobotDirections[y][x];
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        nanobotDirections[y][x] = [0, 0];
                    }
                } else {
                    // Hit a boundary, change direction
                    nanobotDirections[y][x] = [(Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2];
                }
            }
            
            // Periodically check for food in a wider area (every 10 frames)
            if (Math.random() < 0.1) { // 10% chance each frame
                // Look for food in a wider area (10 cells)
                const wideSearchRadius = 10;
                let foodFound = false;
                let foodX = -1;
                let foodY = -1;
                let foodDistance = Infinity;
                
                // Search in a wider area
                for (let r = 1; r <= wideSearchRadius && !foodFound; r++) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        const checkX = Math.round(x + Math.cos(angle) * r);
                        const checkY = Math.round(y + Math.sin(angle) * r);
                        
                        if (checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length) {
                            const particle = grid[checkY][checkX];
                            if (particle !== PARTICLE_TYPES.EMPTY && particle !== PARTICLE_TYPES.NANOBOT && particle !== PARTICLE_TYPES.WALL) {
                                // Calculate distance to this particle
                                const distance = Math.sqrt((checkX - x) ** 2 + (checkY - y) ** 2);
                                if (distance < foodDistance) {
                                    foodDistance = distance;
                                    foodX = checkX;
                                    foodY = checkY;
                                    foodFound = true;
                                }
                            }
                        }
                    }
                }
                
                // If food found in wider area, move toward it
                if (foodFound) {
                    // Calculate direction to food
                    const foodDx = foodX - x;
                    const foodDy = foodY - y;
                    const foodLength = Math.sqrt(foodDx * foodDx + foodDy * foodDy);
                    
                    // Set direction toward food
                    dx = foodDx / foodLength;
                    dy = foodDy / foodLength;
                    
                    // Add some randomness
                    dx += (Math.random() - 0.5) * 0.3;
                    dy += (Math.random() - 0.5) * 0.3;
                    
                    // Normalize
                    const newLength = Math.sqrt(dx * dx + dy * dy);
                    if (newLength > 0) {
                        dx /= newLength;
                        dy /= newLength;
                    }
                    
                    // Update direction
                    nanobotDirections[y][x] = [dx, dy];
                }
            }
            
            // Every 30 frames, do a global search for food
            if (Math.random() < 0.03) { // 3% chance each frame
                // Look for food anywhere on the canvas
                let globalFoodFound = false;
                let globalFoodX = -1;
                let globalFoodY = -1;
                let globalFoodDistance = Infinity;
                
                // Search the entire canvas
                for (let ny = 0; ny < grid.length; ny++) {
                    for (let nx = 0; nx < grid[0].length; nx++) {
                        const particle = grid[ny][nx];
                        if (particle !== PARTICLE_TYPES.EMPTY && particle !== PARTICLE_TYPES.NANOBOT && particle !== PARTICLE_TYPES.WALL) {
                            // Calculate distance to this particle
                            const distance = Math.sqrt((nx - x) ** 2 + (ny - y) ** 2);
                            if (distance < globalFoodDistance) {
                                globalFoodDistance = distance;
                                globalFoodX = nx;
                                globalFoodY = ny;
                                globalFoodFound = true;
                            }
                        }
                    }
                }
                
                // If food found globally, move toward it
                if (globalFoodFound) {
                    // Calculate direction to food
                    const foodDx = globalFoodX - x;
                    const foodDy = globalFoodY - y;
                    const foodLength = Math.sqrt(foodDx * foodDx + foodDy * foodDy);
                    
                    // Set direction toward food with higher weight (80% food, 20% current)
                    dx = dx * 0.2 + (foodDx / foodLength) * 0.8;
                    dy = dy * 0.2 + (foodDy / foodLength) * 0.8;
                    
                    // Normalize
                    const newLength = Math.sqrt(dx * dx + dy * dy);
                    if (newLength > 0) {
                        dx /= newLength;
                        dy /= newLength;
                    }
                    
                    // Update direction
                    nanobotDirections[y][x] = [dx, dy];
                }
            }
        }

        // Update cryo particle
        function updateCryo(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Check for water to freeze - increased range and frequency
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.WATER) {
                            // Always freeze water in range
                            grid[ny][nx] = PARTICLE_TYPES.ICE;
                            iceEvaporationTimers[ny][nx] = 0;
                        }
                    }
                }
            }

            // Simplified movement - always try down first, then diagonals
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                grid[y + 1][x] = PARTICLE_TYPES.CRYO;
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Try diagonal movement in a fixed order
            if (x > 0 && grid[y + 1][x - 1] === PARTICLE_TYPES.EMPTY) {
                grid[y + 1][x - 1] = PARTICLE_TYPES.CRYO;
                grid[y][x] = PARTICLE_TYPES.EMPTY;
            } else if (x < grid[0].length - 1 && grid[y + 1][x + 1] === PARTICLE_TYPES.EMPTY) {
                grid[y + 1][x + 1] = PARTICLE_TYPES.CRYO;
                grid[y][x] = PARTICLE_TYPES.EMPTY;
            }
        }

        // Update ice particle
        function updateIce(x, y) {
            // Check for fire to melt
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.FIRE) {
                            // Melt the ice back into water
                            grid[y][x] = PARTICLE_TYPES.WATER;
                            return;
                        }
                    }
                }
            }

            // Simple evaporation - 0.1% chance to disappear each frame
            if (Math.random() < 0.001) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                return;
            }

            // Optimized ice spreading - increased frequency and chance
            if (Math.random() < 0.4) { // 40% chance per frame
                // Only check cardinal directions (up, down, left, right)
                const spreadDirections = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                // Try to spread to one random direction
                const [dy, dx] = spreadDirections[Math.floor(Math.random() * 4)];
                const ny = y + dy;
                const nx = x + dx;
                
                if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                    if (grid[ny][nx] === PARTICLE_TYPES.WATER) {
                        // 15% chance to freeze adjacent water
                        if (Math.random() < 0.15) {
                            grid[ny][nx] = PARTICLE_TYPES.ICE;
                        }
                    }
                }
            }
        }

        // Update lava particle
        function updateLava(x, y) {
            // Check for water to instantly turn to stone
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.WATER) {
                            // Turn to stone when touching water
                            grid[y][x] = PARTICLE_TYPES.STONE;
                            lavaCoolingTimers[y][x] = 0;
                            return;
                        }
                    }
                }
            }

            // Check for organic matter to burn
            let isBurning = false;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (grid[ny][nx] === PARTICLE_TYPES.PLANT || 
                            grid[ny][nx] === PARTICLE_TYPES.FUNGUS) {
                            // Start burning the organic matter
                            grid[ny][nx] = PARTICLE_TYPES.FIRE;
                            fireCooldowns[ny][nx] = 15;
                            isBurning = true;
                        }
                    }
                }
            }

            // If burning organic matter, don't cool down
            if (isBurning) {
                lavaCoolingTimers[y][x] = 0;
            } else {
                // Increment cooling timer
                lavaCoolingTimers[y][x]++;
                
                // Check if lava should turn to stone (after about 5 seconds at 60 FPS)
                if (lavaCoolingTimers[y][x] > 300) {
                    // Check if there's lava above this cell
                    let hasLavaAbove = false;
                    for (let checkY = y - 1; checkY >= 0; checkY--) {
                        if (grid[checkY][x] === PARTICLE_TYPES.LAVA) {
                            hasLavaAbove = true;
                            break;
                        }
                    }
                    
                    // Turn to stone if there's lava above or if it's been cooling for a while
                    if (hasLavaAbove || lavaCoolingTimers[y][x] > 450) {
                        grid[y][x] = PARTICLE_TYPES.STONE;
                        lavaCoolingTimers[y][x] = 0;
                        return;
                    }
                }
            }

            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                lavaCoolingTimers[y][x] = 0;
                return;
            }

            // Try to move down with minimal horizontal movement
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                // Very slight random drift for natural look
                const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y + 1][x + drift] = PARTICLE_TYPES.LAVA;
                    lavaCoolingTimers[y + 1][x + drift] = lavaCoolingTimers[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    lavaCoolingTimers[y][x] = 0;
                } else {
                    grid[y + 1][x] = PARTICLE_TYPES.LAVA;
                    lavaCoolingTimers[y + 1][x] = lavaCoolingTimers[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    lavaCoolingTimers[y][x] = 0;
                }
                return;
            }

            // Enhanced horizontal movement with minimal spread (thicker than water)
            const maxSpread = 1; // Reduced spread for thicker flow
            const direction = Math.random() < 0.5 ? -1 : 1;
            let moved = false;

            // Try multiple horizontal positions
            for (let spread = 1; spread <= maxSpread; spread++) {
                const testX = x + (direction * spread);
                if (testX >= 0 && testX < grid[0].length) {
                    if (grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                        if (Math.random() < 0.1 && y + 1 < grid.length && grid[y + 1][testX] === PARTICLE_TYPES.EMPTY) {
                            grid[y + 1][testX] = PARTICLE_TYPES.LAVA;
                            lavaCoolingTimers[y + 1][testX] = lavaCoolingTimers[y][x];
                        } else {
                            grid[y][testX] = PARTICLE_TYPES.LAVA;
                            lavaCoolingTimers[y][testX] = lavaCoolingTimers[y][x];
                        }
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        lavaCoolingTimers[y][x] = 0;
                        moved = true;
                        break;
                    }
                }
            }

            // If couldn't move horizontally, try the other direction
            if (!moved && Math.random() < 0.5) {
                const altDirection = -direction;
                const testX = x + altDirection;
                if (testX >= 0 && testX < grid[0].length && grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                    grid[y][testX] = PARTICLE_TYPES.LAVA;
                    lavaCoolingTimers[y][testX] = lavaCoolingTimers[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    lavaCoolingTimers[y][x] = 0;
                }
            }
        }

        // Update spout particles
        function updateSpouts() {
            spoutTimer++;
            
            // Emit water every 5 frames (increased from 15) for more consistent flow
            if (spoutTimer % 5 !== 0) return;
            
            const rows = grid.length;
            const cols = grid[0].length;
            
            // Find all spouts and emit water below them
            for (let y = 0; y < rows - 1; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x] === PARTICLE_TYPES.SPOUT) {
                        // Increased emission chance to 60% for more consistent flow
                        if (Math.random() < 0.6) {
                            // Check if there's space below the spout
                            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                                grid[y + 1][x] = PARTICLE_TYPES.WATER;
                            }
                        }
                    }
                }
            }
        }

        // Draw the grid
        function draw() {
            // Clear with background color
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Create an off-screen canvas for better performance
            const offscreen = document.createElement('canvas');
            offscreen.width = canvas.width;
            offscreen.height = canvas.height;
            const offCtx = offscreen.getContext('2d');

            // Set offscreen canvas background
            offCtx.fillStyle = backgroundColor;
            offCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw to off-screen canvas
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[0].length; x++) {
                    const particle = grid[y][x];
                    if (particle !== PARTICLE_TYPES.EMPTY) {
                        // Draw base particle
                        offCtx.fillStyle = getParticleColor(particle);
                        offCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // Enhanced fire effect with bloom and smoke
                        if (particle === PARTICLE_TYPES.FIRE) {
                            // Draw bloom effect
                            const bloomSize = 2.5; // Increased from 1.5
                            const bloomIntensity = 0.4; // Increased from 0.3
                            
                            // Outer glow
                            offCtx.fillStyle = `rgba(255, 140, 0, ${bloomIntensity * 0.5})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (bloomSize - 1) / 2),
                                (y * CELL_SIZE) - (CELL_SIZE * (bloomSize - 1) / 2),
                                CELL_SIZE * bloomSize,
                                CELL_SIZE * bloomSize
                            );
                            
                            // Middle glow
                            offCtx.fillStyle = `rgba(255, 200, 0, ${bloomIntensity * 0.7})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (bloomSize * 0.7 - 1) / 2),
                                (y * CELL_SIZE) - (CELL_SIZE * (bloomSize * 0.7 - 1) / 2),
                                CELL_SIZE * bloomSize * 0.7,
                                CELL_SIZE * bloomSize * 0.7
                            );
                            
                            // Inner glow
                            offCtx.fillStyle = `rgba(255, 255, 200, ${bloomIntensity})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (bloomSize * 0.4 - 1) / 2),
                                (y * CELL_SIZE) - (CELL_SIZE * (bloomSize * 0.4 - 1) / 2),
                                CELL_SIZE * bloomSize * 0.4,
                                CELL_SIZE * bloomSize * 0.4
                            );
                            
                            // Add subtle smoke effect (30% chance)
                            if (Math.random() < 0.3) {
                                const smokeSize = 1.2;
                                const smokeIntensity = 0.2;
                                const smokeOffset = (Math.random() - 0.5) * 2; // Random horizontal drift
                                
                                offCtx.fillStyle = `rgba(50, 50, 50, ${smokeIntensity})`;
                                offCtx.fillRect(
                                    (x * CELL_SIZE) + smokeOffset,
                                    (y * CELL_SIZE) - CELL_SIZE,
                                    CELL_SIZE * smokeSize,
                                    CELL_SIZE * smokeSize
                                );
                            }
                        }
                        // Draw heat effect on plants that are about to burn
                        else if ((particle === PARTICLE_TYPES.PLANT || particle === PARTICLE_TYPES.FUNGUS) && plantHeatTimers[y][x] > 0) {
                            // Calculate heat intensity based on remaining timer
                            const heatIntensity = plantHeatTimers[y][x] / 30; // 30 is max timer
                            const glowSize = 1.5; // Size multiplier for the glow effect
                            
                            // Draw larger glow effect
                            offCtx.fillStyle = `rgba(255, 140, 0, ${0.3 * (1 - heatIntensity)})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 2),
                                (y * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 2),
                                CELL_SIZE * glowSize,
                                CELL_SIZE * glowSize
                            );
                            
                            // Draw brighter center
                            offCtx.fillStyle = `rgba(255, 200, 0, ${0.4 * (1 - heatIntensity)})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 4),
                                (y * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 4),
                                CELL_SIZE * (glowSize * 0.5),
                                CELL_SIZE * (glowSize * 0.5)
                            );
                        }
                        // Draw heat effect on oil that is about to burn
                        else if (particle === PARTICLE_TYPES.OIL && oilHeatTimers[y][x] > 0) {
                            // Calculate heat intensity based on remaining timer
                            const heatIntensity = oilHeatTimers[y][x] / 8; // 8 is max timer
                            const glowSize = 1.3; // Slightly smaller glow for oil
                            
                            // Draw larger glow effect
                            offCtx.fillStyle = `rgba(255, 140, 0, ${0.5 * (1 - heatIntensity)})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 2),
                                (y * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 2),
                                CELL_SIZE * glowSize,
                                CELL_SIZE * glowSize
                            );
                            
                            // Draw brighter center
                            offCtx.fillStyle = `rgba(255, 200, 0, ${0.6 * (1 - heatIntensity)})`;
                            offCtx.fillRect(
                                (x * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 4),
                                (y * CELL_SIZE) - (CELL_SIZE * (glowSize - 1) / 4),
                                CELL_SIZE * (glowSize * 0.5),
                                CELL_SIZE * (glowSize * 0.5)
                            );
                        }
                        // Draw poison effect on plants
                        else if (particle === PARTICLE_TYPES.PLANT && poisonTimers[y][x] > 0) {
                            const poisonIntensity = poisonTimers[y][x] / 10; // 10 is max timer
                            offCtx.fillStyle = `rgba(128, 0, 128, ${0.4 * (1 - poisonIntensity)})`; // Purple fade
                            offCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        // Draw transforming poison
                        else if (particle === PARTICLE_TYPES.POISON && poisonStates[y][x] === 1) {
                            const transformIntensity = poisonTimers[y][x] / 10;
                            offCtx.fillStyle = `rgba(128, 128, 128, ${0.5 * (1 - transformIntensity)})`; // Gray fade
                            offCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        // Draw dust with fade effect based on remaining lifetime
                        else if (particle === PARTICLE_TYPES.DUST && dustTimers[y][x] > 0) {
                            const dustIntensity = dustTimers[y][x] / 60; // 60 is max timer
                            offCtx.fillStyle = `rgba(169, 169, 169, ${0.3 + (0.7 * dustIntensity)})`; // Gray with fade
                            offCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        // Draw nanobot count
                        if (particle === PARTICLE_TYPES.NANOBOT) {
                            // Draw a small indicator for nanobots
                            offCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            offCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        // Draw corrosion effect
                        if (acidCorrosionTimers[y][x] > 0) {
                            const corrosionIntensity = acidCorrosionTimers[y][x] / 30; // 30 is max timer
                            offCtx.fillStyle = `rgba(255, 0, 0, ${0.3 * (1 - corrosionIntensity)})`; // Red fade
                            offCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        // Ice evaporation effect removed for better performance
                    }
                }
            }

            // Copy off-screen canvas to main canvas
            ctx.drawImage(offscreen, 0, 0);
            
            // Draw nanobot count in the corner
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText(`Nanobots: ${nanobotCount}/${MAX_NANOBOTS}`, 10, 20);
        }

        // Get color for particle type
        function getParticleColor(type) {
            switch (type) {
                case PARTICLE_TYPES.WALL:
                    return '#666';
                case PARTICLE_TYPES.SAND:
                    return '#d2b48c';
                case PARTICLE_TYPES.WATER:
                    return '#4169e1';
                case PARTICLE_TYPES.FIRE:
                    return '#ff8c00';
                case PARTICLE_TYPES.PLANT:
                    return '#228b22';
                case PARTICLE_TYPES.SPOUT:
                    return '#1e90ff';
                case PARTICLE_TYPES.OIL:
                    return '#8B4513';
                case PARTICLE_TYPES.POISON:
                    return '#800080'; // Purple
                case PARTICLE_TYPES.DUST:
                    return '#A9A9A9'; // Gray
                case PARTICLE_TYPES.FUNGUS:
                    return '#3A2A1A'; // Brownish black
                case PARTICLE_TYPES.NANOBOT:
                    return '#A0A0A0'; // Dull metal gray
                case PARTICLE_TYPES.CRYO:
                    return '#00FFFF'; // Cyan
                case PARTICLE_TYPES.ICE:
                    return '#00BFFF'; // Deep Sky Blue
                case PARTICLE_TYPES.LAVA:
                    return '#FF4500'; // Orange Red
                case PARTICLE_TYPES.STONE:
                    return '#696969'; // Dim Gray
                case PARTICLE_TYPES.ACID:
                    return '#00FF00'; // Bright green
                default:
                    return '#000';
            }
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Function to clear the canvas
        function clearCanvas() {
            const rows = grid.length;
            const cols = grid[0].length;
            
            // Reset all grids
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    fireCooldowns[y][x] = 0;
                    plantHeatTimers[y][x] = 0;
                    oilHeatTimers[y][x] = 0;
                    poisonTimers[y][x] = 0;
                    poisonStates[y][x] = 0;
                    dustTimers[y][x] = 0;
                    nanobotDirections[y][x] = [0, 0];
                    lavaCoolingTimers[y][x] = 0;
                    acidCorrosionTimers[y][x] = 0;
                    iceEvaporationTimers[y][x] = 0;
                }
            }
            
            // Reset nanobot count
            nanobotCount = 0;
            
            // Reset spout timer
            spoutTimer = 0;
        }

        // Initialize the game when the page loads
        window.addEventListener('load', init);

        // Update acid particle
        function updateAcid(x, y) {
            // Allow falling through bottom
            if (y + 1 >= grid.length) {
                grid[y][x] = PARTICLE_TYPES.EMPTY;
                acidCorrosionTimers[y][x] = 0;
                return;
            }

            // Check for solid particles to corrode
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = y + dy;
                    const nx = x + dx;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        const targetType = grid[ny][nx];
                        // Only corrode solid particles (not liquids or empty spaces)
                        if (targetType !== PARTICLE_TYPES.EMPTY && 
                            targetType !== PARTICLE_TYPES.WATER && 
                            targetType !== PARTICLE_TYPES.OIL && 
                            targetType !== PARTICLE_TYPES.POISON && 
                            targetType !== PARTICLE_TYPES.LAVA && 
                            targetType !== PARTICLE_TYPES.ACID) {
                            
                            // Start or increment corrosion timer
                            if (acidCorrosionTimers[ny][nx] === 0) {
                                // Different corrosion rates for different materials
                                switch (targetType) {
                                    case PARTICLE_TYPES.WALL:
                                        acidCorrosionTimers[ny][nx] = 30; // Slowest
                                        break;
                                    case PARTICLE_TYPES.STONE:
                                        acidCorrosionTimers[ny][nx] = 25;
                                        break;
                                    case PARTICLE_TYPES.SAND:
                                        acidCorrosionTimers[ny][nx] = 20;
                                        break;
                                    case PARTICLE_TYPES.PLANT:
                                    case PARTICLE_TYPES.FUNGUS:
                                        acidCorrosionTimers[ny][nx] = 15;
                                        break;
                                    case PARTICLE_TYPES.ICE:
                                        acidCorrosionTimers[ny][nx] = 10;
                                        break;
                                    default:
                                        acidCorrosionTimers[ny][nx] = 20;
                                }
                            }
                        }
                    }
                }
            }

            // Try to move down with minimal horizontal movement
            if (grid[y + 1][x] === PARTICLE_TYPES.EMPTY) {
                // Very slight random drift for natural look
                const drift = Math.random() < 0.5 ? 0 : (Math.random() < 0.5 ? 1 : -1);
                if (x + drift >= 0 && x + drift < grid[0].length && grid[y + 1][x + drift] === PARTICLE_TYPES.EMPTY) {
                    grid[y + 1][x + drift] = PARTICLE_TYPES.ACID;
                    acidCorrosionTimers[y + 1][x + drift] = acidCorrosionTimers[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    acidCorrosionTimers[y][x] = 0;
                } else {
                    grid[y + 1][x] = PARTICLE_TYPES.ACID;
                    acidCorrosionTimers[y + 1][x] = acidCorrosionTimers[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    acidCorrosionTimers[y][x] = 0;
                }
                return;
            }

            // Enhanced horizontal movement with minimal spread
            const maxSpread = 1;
            const direction = Math.random() < 0.5 ? -1 : 1;
            let moved = false;

            // Try multiple horizontal positions
            for (let spread = 1; spread <= maxSpread; spread++) {
                const testX = x + (direction * spread);
                if (testX >= 0 && testX < grid[0].length) {
                    if (grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                        if (Math.random() < 0.2 && y + 1 < grid.length && grid[y + 1][testX] === PARTICLE_TYPES.EMPTY) {
                            grid[y + 1][testX] = PARTICLE_TYPES.ACID;
                            acidCorrosionTimers[y + 1][testX] = acidCorrosionTimers[y][x];
                        } else {
                            grid[y][testX] = PARTICLE_TYPES.ACID;
                            acidCorrosionTimers[y][testX] = acidCorrosionTimers[y][x];
                        }
                        grid[y][x] = PARTICLE_TYPES.EMPTY;
                        acidCorrosionTimers[y][x] = 0;
                        moved = true;
                        break;
                    }
                }
            }

            // If couldn't move horizontally, try the other direction
            if (!moved && Math.random() < 0.5) {
                const altDirection = -direction;
                const testX = x + altDirection;
                if (testX >= 0 && testX < grid[0].length && grid[y][testX] === PARTICLE_TYPES.EMPTY) {
                    grid[y][testX] = PARTICLE_TYPES.ACID;
                    acidCorrosionTimers[y][testX] = acidCorrosionTimers[y][x];
                    grid[y][x] = PARTICLE_TYPES.EMPTY;
                    acidCorrosionTimers[y][x] = 0;
                }
            }
        }

        // Chat functionality
        const chatBox = document.getElementById('chatBox');
        const activeComments = chatBox.querySelector('.active-comments');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const exportButton = document.getElementById('exportButton');
        const hiddenCommentsHeader = document.getElementById('hiddenCommentsHeader');
        const hiddenCommentsContent = document.getElementById('hiddenCommentsContent');
        const hiddenCountSpan = document.querySelector('.hidden-count');

        // Supabase configuration
        const SUPABASE_URL = 'https://hohwexjhpmkdkryhxcek.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhvaHdleGpocG1rZGtyeWh4Y2VrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUyNDAzNzgsImV4cCI6MjA2MDgxNjM3OH0.db81CPsglOady0TOau3mWaUrPmmv8lxnwMk8NM-L5nQ';

        // Update hidden comments count
        function updateHiddenCount() {
            const userHiddenComments = JSON.parse(localStorage.getItem('hiddenComments') || '[]');
            const hiddenCount = userHiddenComments.length;
            hiddenCountSpan.textContent = `(${hiddenCount})`;
        }

        // Load comments from Supabase
        async function loadComments() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/comments?select=*&order=timestamp.desc`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch comments');
                }
                
                const comments = await response.json();
                
                // Clear existing comments
                activeComments.innerHTML = '';
                hiddenCommentsContent.innerHTML = '';
                
                // Get user's hidden comments from localStorage
                const userHiddenComments = JSON.parse(localStorage.getItem('hiddenComments') || '[]');
                
                // Add comments to appropriate sections
                comments.forEach(comment => {
                    if (userHiddenComments.includes(comment.id)) {
                        addCommentToHiddenSection(comment);
                    } else {
                        addCommentToActiveSection(comment);
                    }
                });
                
                updateHiddenCount();
            } catch (error) {
                console.error('Error loading comments:', error);
            }
        }

        // Add a comment to the active section
        function addCommentToActiveSection(comment) {
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment';
            commentDiv.dataset.id = comment.id;
            commentDiv.innerHTML = `
                <div class="comment-text">${comment.text}</div>
                <div class="timestamp">${new Date(comment.timestamp).toLocaleString()}</div>
            `;
            
            // Add hide button
            const hideButton = document.createElement('button');
            hideButton.className = 'hide-button';
            hideButton.textContent = '×';
            hideButton.onclick = () => toggleCommentVisibility(comment.id);
            commentDiv.appendChild(hideButton);
            
            activeComments.appendChild(commentDiv);
        }

        // Add a comment to the hidden section
        function addCommentToHiddenSection(comment) {
            const hiddenComment = document.createElement('div');
            hiddenComment.className = 'comment';
            hiddenComment.dataset.id = comment.id;
            hiddenComment.innerHTML = `
                <div class="comment-text">${comment.text}</div>
                <div class="timestamp">${new Date(comment.timestamp).toLocaleString()}</div>
            `;
            
            const restoreButton = document.createElement('button');
            restoreButton.className = 'restore-button';
            restoreButton.textContent = '↺ Restore';
            restoreButton.onclick = () => toggleCommentVisibility(comment.id);
            hiddenComment.appendChild(restoreButton);
            
            hiddenCommentsContent.appendChild(hiddenComment);
        }

        // Toggle comment visibility
        async function toggleCommentVisibility(commentId) {
            try {
                // Get current hidden comments from localStorage
                const userHiddenComments = JSON.parse(localStorage.getItem('hiddenComments') || '[]');
                
                // Toggle the comment's hidden state
                const newHiddenState = !userHiddenComments.includes(commentId);
                
                if (newHiddenState) {
                    // Add to hidden comments
                    userHiddenComments.push(commentId);
                } else {
                    // Remove from hidden comments
                    const index = userHiddenComments.indexOf(commentId);
                    if (index > -1) {
                        userHiddenComments.splice(index, 1);
                    }
                }
                
                // Save updated hidden comments to localStorage
                localStorage.setItem('hiddenComments', JSON.stringify(userHiddenComments));
                
                // Update the hidden count immediately
                updateHiddenCount();
                
                // Reload comments to reflect the change
                loadComments();
            } catch (error) {
                console.error('Error toggling comment visibility:', error);
            }
        }

        // Handle sending messages
        async function handleSendMessage() {
            const text = messageInput.value.trim();
            if (text) {
                try {
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/comments`, {
                        method: 'POST',
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({ text })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to add comment');
                    }
                    
                    messageInput.value = '';
                    loadComments(); // Reload all comments to show the new one
                } catch (error) {
                    console.error('Error sending comment:', error);
                }
            }
        }

        // Export comments to text file
        async function exportComments() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/comments?select=*&order=timestamp.desc`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch comments');
                }
                
                const comments = await response.json();
                
                // Get user's hidden comments from localStorage
                const userHiddenComments = JSON.parse(localStorage.getItem('hiddenComments') || '[]');
                
                const activeCommentsList = comments
                    .filter(comment => !userHiddenComments.includes(comment.id))
                    .map(comment => {
                        const timestamp = new Date(comment.timestamp).toLocaleString();
                        return `[${timestamp}] ${comment.text}`;
                    });

                const hiddenCommentsList = comments
                    .filter(comment => userHiddenComments.includes(comment.id))
                    .map(comment => {
                        const timestamp = new Date(comment.timestamp).toLocaleString();
                        return `[${timestamp}] ${comment.text} (hidden)`;
                    });

                const allComments = [...activeCommentsList, ...hiddenCommentsList].join('\n\n');
                const blob = new Blob([allComments], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `element_ideas_${new Date().toISOString().split('T')[0]}.txt`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Error exporting comments:', error);
            }
        }

        // Event listeners
        sendButton.addEventListener('click', handleSendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSendMessage();
            }
        });
        exportButton.addEventListener('click', exportComments);
        hiddenCommentsHeader.addEventListener('click', () => {
            hiddenCommentsContent.classList.toggle('expanded');
        });

        // Load comments when the page loads
        window.addEventListener('load', () => {
            init();
            loadComments();
        });

        // Function to apply a theme
        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;

            // Apply each CSS variable from the theme
            Object.entries(theme).forEach(([property, value]) => {
                document.documentElement.style.setProperty(property, value);
            });
        }
    </script>
</body>
</html> 